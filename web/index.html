<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Semantic Synchrony</title>
    <link rel="icon" type="image/png" href="../plugins/chrome/icon.png">
    <style>
        :root {
            --bg-color: #ffffff;
            --text-color: #333333;
            --muted-color: #808080;
            --border-color: #cccccc;
            --hover-bg: #f0f0f0;
            --selected-bg: #cce5ff;
            --priority-color: #cc0000;
            --success-color: #00aa00;
            --warning-color: #cc8800;
            --indent-width: 24px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            background-color: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        header {
            padding: 8px 16px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 16px;
            background: #f8f8f8;
        }

        header h1 {
            font-size: 16px;
            font-weight: normal;
            color: #0066cc;
        }

        #connection-status {
            font-size: 12px;
            color: var(--muted-color);
        }

        #connection-status.connected {
            color: var(--success-color);
        }

        #connection-status.error {
            color: var(--priority-color);
        }

        /* Toolbar components (used in header and per-pane toolbars) */
        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .toolbar-separator {
            width: 1px;
            height: 20px;
            background: var(--border-color);
            margin: 0 8px;
        }

        .toolbar-btn {
            padding: 4px 8px;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            color: var(--text-color);
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 28px;
        }

        .toolbar-btn:hover {
            background: #e8e8e8;
        }

        .toolbar-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .toolbar-btn.active {
            background: #0066cc;
            color: white;
            border-color: #0066cc;
        }

        .toolbar-label {
            font-size: 12px;
            color: var(--muted-color);
            margin-right: 4px;
        }

        .depth-select {
            padding: 3px 6px;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 13px;
            color: var(--text-color);
            cursor: pointer;
        }

        .depth-select:focus {
            outline: none;
            border-color: #0066cc;
        }

        /* Panes container */
        #panes-container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* Pane wrapper (includes search, toolbar, and content) */
        .pane-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 2px solid transparent;
        }

        .pane-wrapper.active-pane {
            border-color: #0066cc;
        }

        #pane-wrapper-1 {
            display: none;
        }

        .split-view #pane-wrapper-1 {
            display: flex;
        }

        #pane-divider {
            display: none;
            width: 4px;
            background: var(--border-color);
            cursor: col-resize;
        }

        #pane-divider:hover {
            background: #0066cc;
        }

        .split-view #pane-divider {
            display: block;
        }

        /* Per-pane search */
        .pane-search {
            padding: 8px 16px;
            border-bottom: 1px solid var(--border-color);
            background: #f8f8f8;
        }

        .search-input {
            width: 100%;
            padding: 6px 12px;
            background: white;
            border: 1px solid var(--border-color);
            color: var(--text-color);
            font-family: inherit;
            font-size: 14px;
            border-radius: 4px;
        }

        .search-input:focus {
            outline: none;
            border-color: #0066cc;
        }

        /* Per-pane toolbar */
        .pane-toolbar {
            padding: 6px 16px;
            border-bottom: 1px solid var(--border-color);
            background: #f8f8f8;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Pane content (tree view) */
        .pane-content {
            flex: 1;
            overflow: auto;
            padding: 8px 0;
        }

        /* Tree view */
        .tree-node {
            padding: 2px 16px;
            cursor: pointer;
            display: flex;
            align-items: flex-start;
            gap: 6px;
        }

        .tree-node:hover {
            background-color: var(--hover-bg);
        }

        .tree-node.selected {
            background-color: var(--selected-bg);
        }

        .tree-node.root {
            font-weight: bold;
        }

        .tree-node.editing {
            background-color: var(--hover-bg);
        }

        .toggle {
            width: 16px;
            flex-shrink: 0;
            color: var(--muted-color);
            user-select: none;
        }

        .toggle:hover {
            color: var(--text-color);
        }

        .node-content {
            flex: 1;
            display: flex;
            align-items: flex-start;
            gap: 8px;
        }

        .node-title {
            flex: 1;
            word-wrap: break-word;
        }

        .has-alias {
            text-decoration: underline;
        }

        .node-meta {
            font-size: 12px;
            color: var(--muted-color);
            flex-shrink: 0;
        }

        .node-priority {
            color: #cc0000;
            cursor: default;
            font-weight: bold;
            width: 12px;
            flex-shrink: 0;
            text-align: center;
        }

        .priority-spacer {
            width: 12px;
            flex-shrink: 0;
        }

        .children {
            margin-left: var(--indent-width);
        }

        .children.collapsed {
            display: none;
        }


        /* Inline editing */
        .edit-input {
            flex: 1;
            padding: 2px 6px;
            background: white;
            border: 1px solid #0066cc;
            color: var(--text-color);
            font-family: inherit;
            font-size: 14px;
            border-radius: 2px;
        }

        .edit-input:focus {
            outline: none;
        }

        /* Status bar */
        footer {
            padding: 4px 16px;
            border-top: 1px solid var(--border-color);
            font-size: 12px;
            color: var(--muted-color);
            display: flex;
            justify-content: space-between;
            background: #f8f8f8;
        }

        /* Overlays */
        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }

        .overlay.visible {
            display: flex;
        }

        .overlay-content {
            background: white;
            border: 1px solid var(--border-color);
            padding: 24px;
            border-radius: 8px;
            max-width: 500px;
            min-width: 300px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        }

        .overlay-content h2 {
            margin-bottom: 16px;
            color: #0066cc;
        }

        .overlay-content table {
            width: 100%;
        }

        .overlay-content td {
            padding: 4px 8px;
        }

        .overlay-content td:first-child {
            color: #0066cc;
            font-weight: bold;
            white-space: nowrap;
        }

        /* Properties panel */
        .property-row {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }

        .property-row label {
            width: 80px;
            color: var(--muted-color);
        }

        .property-row input,
        .property-row select {
            flex: 1;
            padding: 6px 10px;
            background: white;
            border: 1px solid var(--border-color);
            color: var(--text-color);
            font-family: inherit;
            font-size: 14px;
            border-radius: 4px;
        }

        .property-row input:focus,
        .property-row select:focus {
            outline: none;
            border-color: #0066cc;
        }

        .button-row {
            display: flex;
            gap: 8px;
            margin-top: 16px;
            justify-content: flex-end;
        }

        button {
            padding: 6px 16px;
            background: #f0f0f0;
            border: 1px solid var(--border-color);
            color: var(--text-color);
            font-family: inherit;
            font-size: 14px;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover {
            background: #e0e0e0;
        }

        button.primary {
            background: #0066cc;
            border-color: #0066cc;
            color: white;
        }

        button.primary:hover {
            background: #0055aa;
        }

        button.danger {
            background: #cc0000;
            border-color: #cc0000;
            color: white;
        }

        button.danger:hover {
            background: #aa0000;
        }

        /* Loading state */
        .loading {
            color: var(--muted-color);
            padding: 16px;
            text-align: center;
        }

        /* Confirm dialog */
        .confirm-message {
            margin-bottom: 16px;
            line-height: 1.6;
        }

        /* Source color legend */
        #source-legend {
            display: flex;
            gap: 12px;
            font-size: 11px;
            margin-left: auto;  /* Push to the right */
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <header>
        <h1>Semantic Synchrony</h1>
        <span id="connection-status">Disconnected</span>
        <div id="source-legend"></div>
        <button class="toolbar-btn" id="btn-split" onclick="toggleSplit()" title="Toggle split view (C-x 3)">⊞</button>
    </header>

    <div id="panes-container">
        <div class="pane-wrapper active-pane" id="pane-wrapper-0" onclick="setActivePane(0)">
            <div class="pane-search">
                <input type="text" class="search-input" id="search-input-0" placeholder="Search... (press / to focus)" />
            </div>
            <div class="pane-toolbar">
                <div class="toolbar-group">
                    <button class="toolbar-btn" id="btn-back-0" onclick="popView()" title="Go back (Backspace)">◀</button>
                    <button class="toolbar-btn" id="btn-forward-0" onclick="forwardView()" title="Go forward">▶</button>
                </div>
                <div class="toolbar-separator"></div>
                <div class="toolbar-group">
                    <span class="toolbar-label">View:</span>
                    <button class="toolbar-btn active" id="btn-forward-view-0" onclick="setViewStyle('forward')" title="Forward view (children)">▼</button>
                    <button class="toolbar-btn" id="btn-backward-view-0" onclick="setViewStyle('backward')" title="Backward view (parents)">▲</button>
                </div>
                <div class="toolbar-separator"></div>
                <div class="toolbar-group">
                    <span class="toolbar-label">Depth:</span>
                    <select id="depth-select-0" class="depth-select" onchange="setViewDepth(0, this.value)">
                        <option value="1">1</option>
                        <option value="2" selected>2</option>
                        <option value="3">3</option>
                        <option value="4">4</option>
                    </select>
                </div>
                <div class="toolbar-separator"></div>
                <div class="toolbar-group">
                    <button class="toolbar-btn" id="btn-refresh-0" onclick="refreshView()" title="Refresh (r)">↻</button>
                </div>
            </div>
            <main id="tree-container-0" class="pane-content">
                <div class="loading">Connecting to server...</div>
            </main>
        </div>
        <div id="pane-divider"></div>
        <div class="pane-wrapper" id="pane-wrapper-1" onclick="setActivePane(1)">
            <div class="pane-search">
                <input type="text" class="search-input" id="search-input-1" placeholder="Search... (press / to focus)" />
            </div>
            <div class="pane-toolbar">
                <div class="toolbar-group">
                    <button class="toolbar-btn" id="btn-back-1" onclick="popViewPane(1)" title="Go back">◀</button>
                    <button class="toolbar-btn" id="btn-forward-1" onclick="forwardViewPane(1)" title="Go forward">▶</button>
                </div>
                <div class="toolbar-separator"></div>
                <div class="toolbar-group">
                    <span class="toolbar-label">View:</span>
                    <button class="toolbar-btn active" id="btn-forward-view-1" onclick="setViewStylePane('forward', 1)" title="Forward view (children)">▼</button>
                    <button class="toolbar-btn" id="btn-backward-view-1" onclick="setViewStylePane('backward', 1)" title="Backward view (parents)">▲</button>
                </div>
                <div class="toolbar-separator"></div>
                <div class="toolbar-group">
                    <span class="toolbar-label">Depth:</span>
                    <select id="depth-select-1" class="depth-select" onchange="setViewDepth(1, this.value)">
                        <option value="1">1</option>
                        <option value="2" selected>2</option>
                        <option value="3">3</option>
                        <option value="4">4</option>
                    </select>
                </div>
                <div class="toolbar-separator"></div>
                <div class="toolbar-group">
                    <button class="toolbar-btn" id="btn-refresh-1" onclick="refreshViewPane(1)" title="Refresh">↻</button>
                </div>
            </div>
            <main id="tree-container-1" class="pane-content">
                <div class="loading">Click to activate</div>
            </main>
        </div>
    </div>

    <footer>
        <span id="status-message">Press ? for help</span>
        <span id="node-count"></span>
    </footer>

    <!-- Help overlay -->
    <div id="help-overlay" class="overlay">
        <div class="overlay-content">
            <h2>Keyboard Shortcuts</h2>
            <table>
                <tr><td colspan="2" style="color: var(--muted-color); padding-top: 8px;">Navigation</td></tr>
                <tr><td>Enter</td><td>Focus selected note (push view)</td></tr>
                <tr><td>Backspace</td><td>Go back in history</td></tr>
                <tr><td>j / k</td><td>Move down / up</td></tr>
                <tr><td>h / l</td><td>Collapse / expand</td></tr>
                <tr><td>/</td><td>Focus search</td></tr>
                <tr><td>r</td><td>Refresh view</td></tr>
                <tr><td>g</td><td>Go to alias or open URL</td></tr>
                <tr><td>Tab</td><td>Switch pane (in split view)</td></tr>
                <tr><td colspan="2" style="color: var(--muted-color); padding-top: 8px;">Editing</td></tr>
                <tr><td>e</td><td>Edit selected note title</td></tr>
                <tr><td>n</td><td>Create new child note</td></tr>
                <tr><td>N</td><td>Create new sibling note</td></tr>
                <tr><td>p</td><td>Edit properties (weight, priority, etc.)</td></tr>
                <tr><td>d</td><td>Delete selected note</td></tr>
                <tr><td colspan="2" style="color: var(--muted-color); padding-top: 8px;">Other</td></tr>
                <tr><td>Escape</td><td>Cancel / close</td></tr>
                <tr><td>?</td><td>Toggle this help</td></tr>
            </table>
            <p style="margin-top: 16px; color: var(--muted-color);">Press Escape or ? to close</p>
        </div>
    </div>

    <!-- Properties overlay -->
    <div id="properties-overlay" class="overlay">
        <div class="overlay-content">
            <h2>Edit Properties</h2>
            <div class="property-row">
                <label>Title</label>
                <input type="text" id="prop-title" />
            </div>
            <div class="property-row">
                <label>Weight</label>
                <input type="range" id="prop-weight" min="0.1" max="1" step="0.1" />
                <span id="prop-weight-value" style="width: 30px; text-align: right;">0.5</span>
            </div>
            <div class="property-row">
                <label>Priority</label>
                <input type="range" id="prop-priority" min="0" max="1" step="0.1" />
                <span id="prop-priority-value" style="width: 30px; text-align: right;">-</span>
            </div>
            <div class="property-row">
                <label>Source</label>
                <select id="prop-source"></select>
            </div>
            <div class="property-row">
                <label>Shortcut</label>
                <input type="text" id="prop-shortcut" placeholder="(optional)" />
            </div>
            <div class="button-row">
                <button onclick="hideProperties()">Cancel</button>
                <button class="primary" onclick="saveProperties()">Save</button>
            </div>
        </div>
    </div>

    <!-- Confirm delete overlay -->
    <div id="confirm-overlay" class="overlay">
        <div class="overlay-content">
            <h2>Confirm Delete</h2>
            <div class="confirm-message" id="confirm-message"></div>
            <div class="button-row">
                <button onclick="hideConfirm()">Cancel</button>
                <button class="danger" onclick="confirmDelete()">Delete</button>
            </div>
        </div>
    </div>

    <!-- New note overlay -->
    <div id="new-note-overlay" class="overlay">
        <div class="overlay-content">
            <h2 id="new-note-title">New Note</h2>
            <div class="property-row">
                <label>Title</label>
                <input type="text" id="new-note-input" placeholder="Enter note title..." />
            </div>
            <div class="button-row">
                <button onclick="hideNewNote()">Cancel</button>
                <button class="primary" onclick="createNewNote()">Create</button>
            </div>
        </div>
    </div>

    <script>
    // =============================================================================
    // State Management
    // =============================================================================

    const State = {
        // Connection
        ws: null,
        connected: false,
        serverUrl: 'ws://localhost:8182/gremlin',

        // Configuration from server
        config: null,
        sourcesByName: {},

        // View state
        rootId: null,
        view: null,
        selectedId: null,
        expandedNodes: new Set(),
        history: [],
        forwardHistory: [],
        viewStyle: 'forward',  // 'forward' or 'backward'

        // Filter settings
        filter: {
            minSource: 'private',
            defaultSource: 'private',
            minWeight: 0.0,
            defaultWeight: 0.5
        },

        // UI state
        searchQuery: '',
        editingNodeId: null,
        pendingCallback: null,
        newNoteMode: null,

        // Split view
        splitView: false,
        activePane: 0,  // 0 or 1
        panes: [
            { rootId: null, view: null, selectedId: null, expandedNodes: new Set(), history: [], forwardHistory: [], viewStyle: 'forward', viewDepth: 2, lastSearchQuery: null },
            { rootId: null, view: null, selectedId: null, expandedNodes: new Set(), history: [], forwardHistory: [], viewStyle: 'forward', viewDepth: 2, lastSearchQuery: null }
        ]
    };

    // Special marker for search results that we want to be able to navigate back to
    const SEARCH_RESULT_PREFIX = '__search__:';

    // Get current pane state
    function getPane() {
        return State.panes[State.activePane];
    }

    // Initialize pane 0 to share references with State
    function initializePaneState() {
        const pane = State.panes[0];
        pane.history = State.history;
        pane.forwardHistory = State.forwardHistory;
        pane.expandedNodes = State.expandedNodes;
    }
    initializePaneState();

    // =============================================================================
    // Color Utilities (matching smsn-mode)
    // =============================================================================

    function parseColor(numericColor) {
        // Convert numeric color (e.g., 0xff0000) to RGB
        const blue = numericColor % 256;
        const green = Math.floor(numericColor / 256) % 256;
        const red = Math.floor(numericColor / 65536);
        return { r: red, g: green, b: blue };
    }

    function colorToHex(color) {
        const r = Math.round(color.r).toString(16).padStart(2, '0');
        const g = Math.round(color.g).toString(16).padStart(2, '0');
        const b = Math.round(color.b).toString(16).padStart(2, '0');
        return `#${r}${g}${b}`;
    }

    function darkenColor(color, factor) {
        // Darken by multiplying RGB values
        return {
            r: color.r * factor,
            g: color.g * factor,
            b: color.b * factor
        };
    }

    function fadeColor(color, weight) {
        // Fade toward white based on weight (lower weight = more faded)
        // This matches smsn-mode's fade function
        function fade(c, w) {
            const low = c + (255 - c) * 0.9375; // weighted toward white
            const high = c;
            return low + (high - low) * w;
        }
        return {
            r: fade(color.r, weight),
            g: fade(color.g, weight),
            b: fade(color.b, weight)
        };
    }

    function getNoteColor(source, weight) {
        const sourceConfig = State.sourcesByName[source];
        if (!sourceConfig || !sourceConfig.color) {
            return '#333333'; // fallback
        }

        const baseColor = parseColor(sourceConfig.color);
        // Darken for better readability on white background
        const darkenedColor = darkenColor(baseColor, 0.6);
        // Fade based on weight (lower weight = more faded toward white)
        const fadedColor = fadeColor(darkenedColor, weight);
        return colorToHex(fadedColor);
    }

    function getSourceColor(source) {
        const sourceConfig = State.sourcesByName[source];
        if (!sourceConfig || !sourceConfig.color) {
            return '#333333';
        }
        return colorToHex(parseColor(sourceConfig.color));
    }

    // =============================================================================
    // WebSocket Communication
    // =============================================================================

    function connect() {
        updateConnectionStatus('connecting');

        State.ws = new WebSocket(State.serverUrl);

        State.ws.onopen = () => {
            State.connected = true;
            updateConnectionStatus('connected');
            // First get configuration, then find roots
            getConfiguration();
        };

        State.ws.onclose = () => {
            State.connected = false;
            updateConnectionStatus('disconnected');
            setTimeout(connect, 3000);
        };

        State.ws.onerror = (err) => {
            console.error('WebSocket error:', err);
            updateConnectionStatus('error');
        };

        State.ws.onmessage = (event) => {
            try {
                const response = JSON.parse(event.data);
                handleResponse(response);
            } catch (e) {
                console.error('Failed to parse response:', e);
            }
        };
    }

    function sendAction(action, callback = null) {
        if (!State.connected) {
            console.warn('Not connected');
            return;
        }

        if (callback) {
            State.pendingCallback = callback;
        }

        const request = {
            op: 'eval',
            processor: '',
            args: {
                language: 'smsn',
                gremlin: JSON.stringify(action)
            }
        };

        State.ws.send(JSON.stringify(request));
    }

    function handleResponse(response) {
        if (response.status && response.status.code !== 200) {
            console.error('Server error:', response.status);
            setStatusMessage('Error: ' + (response.status.message || 'Unknown error'));
            State.pendingCallback = null;
            return;
        }

        if (response.result && response.result.data && response.result.data.length > 0) {
            const data = JSON.parse(response.result.data[0]);

            if (State.pendingCallback) {
                State.pendingCallback(data);
                State.pendingCallback = null;
            } else if (data.view) {
                State.view = data.view;
                State.rootId = data.root || (data.view.id);
                // Also sync to active pane
                const pane = State.panes[State.activePane];
                pane.view = State.view;
                pane.rootId = State.rootId;
                render();
                updateToolbar();
                setStatusMessage('View loaded');
            }
        }
    }

    // =============================================================================
    // Server Actions
    // =============================================================================

    function getConfiguration() {
        sendAction({
            action: 'net.fortytwo.smsn.server.actions.GetConfiguration'
        }, (data) => {
            if (data.configuration) {
                const config = JSON.parse(data.configuration);
                State.config = config;

                // Build source lookup
                if (config.sources) {
                    State.sourcesByName = {};
                    config.sources.forEach(s => {
                        State.sourcesByName[s.name] = s;
                    });

                    // Update source dropdown and legend
                    updateSourceOptions();
                    updateSourceLegend();
                }
            }
            // Now load the initial view
            findRoots();
        });
    }

    function getView(rootId, height = null) {
        const pane = getPane();
        const viewHeight = height || pane.viewDepth || 2;
        sendAction({
            action: 'net.fortytwo.smsn.server.actions.GetView',
            root: rootId,
            height: viewHeight,
            filter: State.filter,
            style: pane.viewStyle
        });
        updateToolbar();
    }

    function search(query) {
        sendAction({
            action: 'net.fortytwo.smsn.server.actions.Search',
            query: query,
            queryType: 'FullText',
            height: 1,
            filter: State.filter,
            titleCutoff: 100
        });
    }

    function searchInPane(query, paneIndex) {
        const pane = State.panes[paneIndex];
        // Save current view to history before showing search results
        if (pane.rootId) {
            pane.history.push(pane.rootId);
            pane.forwardHistory.length = 0;
        }
        // Save the search query so we can re-execute it when navigating back
        pane.lastSearchQuery = query;
        sendAction({
            action: 'net.fortytwo.smsn.server.actions.Search',
            query: query,
            queryType: 'FullText',
            height: 1,
            filter: State.filter,
            titleCutoff: 100
        }, (data) => {
            if (data.view) {
                pane.view = data.view;
                // Use a special marker so we know this is a search result
                pane.rootId = SEARCH_RESULT_PREFIX + query;
                if (paneIndex === State.activePane) {
                    State.view = pane.view;
                    State.rootId = pane.rootId;
                }
                render();
                updateToolbar();
                setStatusMessage(`Found ${countNodes(data.view)} results`);
            }
        });
    }

    function findRoots() {
        sendAction({
            action: 'net.fortytwo.smsn.server.actions.FindRoots',
            height: 2,
            filter: State.filter
        });
    }

    function setProperty(nodeId, propertyName, value, callback = null) {
        sendAction({
            action: 'net.fortytwo.smsn.server.actions.SetProperties',
            id: nodeId,
            name: propertyName,
            value: value,
            filter: State.filter
        }, callback);
    }

    function updateView(rootId, viewContent, height = 2) {
        sendAction({
            action: 'net.fortytwo.smsn.server.actions.UpdateView',
            root: rootId,
            view: viewContent,
            viewFormat: 'wiki',
            height: height,
            filter: State.filter,
            style: 'forward'
        }, (data) => {
            if (data.view) {
                State.view = data.view;
                State.rootId = data.root || data.view.id;
                render();
                setStatusMessage('Updated');
            }
        });
    }

    // =============================================================================
    // Navigation
    // =============================================================================

    function pushView(nodeId) {
        const pane = getPane();
        if (pane.rootId) {
            pane.history.push(pane.rootId);
            pane.forwardHistory.length = 0;  // Clear forward history
        }
        if (State.activePane === 0) {
            getView(nodeId);
        } else {
            getViewForPane(nodeId, State.activePane);
        }
    }

    function popView() {
        const pane = getPane();
        if (pane.history.length > 0) {
            if (pane.rootId) {
                pane.forwardHistory.push(pane.rootId);
            }
            const prevId = pane.history.pop();
            navigateToId(prevId, State.activePane);
        }
        updateToolbar();
    }

    function forwardView() {
        const pane = getPane();
        if (pane.forwardHistory.length > 0) {
            if (pane.rootId) {
                pane.history.push(pane.rootId);
            }
            const nextId = pane.forwardHistory.pop();
            navigateToId(nextId, State.activePane);
        }
        updateToolbar();
    }

    function navigateToId(targetId, paneIndex) {
        // Check if this is a search result marker
        if (targetId && targetId.startsWith(SEARCH_RESULT_PREFIX)) {
            const query = targetId.substring(SEARCH_RESULT_PREFIX.length);
            // Re-execute the search
            reExecuteSearch(query, paneIndex);
        } else {
            // Normal view navigation
            if (paneIndex === 0) {
                getView(targetId);
            } else {
                getViewForPane(targetId, paneIndex);
            }
        }
    }

    function reExecuteSearch(query, paneIndex) {
        const pane = State.panes[paneIndex];
        pane.lastSearchQuery = query;
        sendAction({
            action: 'net.fortytwo.smsn.server.actions.Search',
            query: query,
            queryType: 'FullText',
            height: 1,
            filter: State.filter,
            titleCutoff: 100
        }, (data) => {
            if (data.view) {
                pane.view = data.view;
                pane.rootId = SEARCH_RESULT_PREFIX + query;
                if (paneIndex === State.activePane) {
                    State.view = pane.view;
                    State.rootId = pane.rootId;
                }
                render();
                updateToolbar();
                setStatusMessage(`Search: "${query}"`);
            }
        });
    }

    function refreshView() {
        const pane = getPane();
        if (pane.rootId) {
            // Handle refresh of search results
            if (pane.rootId.startsWith(SEARCH_RESULT_PREFIX)) {
                const query = pane.rootId.substring(SEARCH_RESULT_PREFIX.length);
                reExecuteSearch(query, State.activePane);
            } else if (State.activePane === 0) {
                getView(pane.rootId);
            } else {
                getViewForPane(pane.rootId, State.activePane);
            }
        } else {
            findRoots();
        }
    }

    function setViewStyle(style) {
        const pane = getPane();
        pane.viewStyle = style;
        if (State.activePane === 0) {
            State.viewStyle = style;
        }
        updateToolbar();
        if (pane.rootId) {
            if (State.activePane === 0) {
                getView(pane.rootId);
            } else {
                getViewForPane(pane.rootId, State.activePane);
            }
        }
    }

    function updateToolbar() {
        // Update both panes' toolbars
        for (let i = 0; i < 2; i++) {
            const pane = State.panes[i];
            const backBtn = document.getElementById(`btn-back-${i}`);
            const fwdBtn = document.getElementById(`btn-forward-${i}`);
            const fwdViewBtn = document.getElementById(`btn-forward-view-${i}`);
            const bkViewBtn = document.getElementById(`btn-backward-view-${i}`);

            if (backBtn) backBtn.disabled = pane.history.length === 0;
            if (fwdBtn) fwdBtn.disabled = pane.forwardHistory.length === 0;
            if (fwdViewBtn) fwdViewBtn.classList.toggle('active', pane.viewStyle === 'forward');
            if (bkViewBtn) bkViewBtn.classList.toggle('active', pane.viewStyle === 'backward');
        }

        document.getElementById('btn-split').classList.toggle('active', State.splitView);
    }

    function toggleSplit() {
        State.splitView = !State.splitView;
        document.getElementById('panes-container').classList.toggle('split-view', State.splitView);

        // If opening split and pane 1 has no view, copy current view
        if (State.splitView && !State.panes[1].view) {
            State.panes[1].rootId = State.panes[0].rootId;
            State.panes[1].view = JSON.parse(JSON.stringify(State.panes[0].view));
            State.panes[1].viewStyle = State.panes[0].viewStyle;
            renderPane(1);
        }

        updateToolbar();
    }

    function setActivePane(index) {
        if (State.activePane === index) return;

        // Save current state to old pane
        syncStateToPane(State.activePane);

        State.activePane = index;

        // Load state from new pane
        syncPaneToState(index);

        // Update visual - use pane-wrapper class
        document.querySelectorAll('.pane-wrapper').forEach((el, i) => {
            el.classList.toggle('active-pane', i === index);
        });

        updateToolbar();
    }

    function syncStateToPane(paneIndex) {
        const pane = State.panes[paneIndex];
        pane.rootId = State.rootId;
        pane.view = State.view;
        pane.selectedId = State.selectedId;
        pane.expandedNodes = State.expandedNodes;
        pane.history = State.history;
        pane.forwardHistory = State.forwardHistory;
        pane.viewStyle = State.viewStyle;
    }

    function syncPaneToState(paneIndex) {
        const pane = State.panes[paneIndex];
        State.rootId = pane.rootId;
        State.view = pane.view;
        State.selectedId = pane.selectedId;
        State.expandedNodes = pane.expandedNodes;
        State.history = pane.history;
        State.forwardHistory = pane.forwardHistory;
        State.viewStyle = pane.viewStyle;
    }

    function selectNode(nodeId) {
        State.selectedId = nodeId;
        getPane().selectedId = nodeId;
        render();
    }

    function toggleExpand(nodeId) {
        if (State.expandedNodes.has(nodeId)) {
            State.expandedNodes.delete(nodeId);
        } else {
            State.expandedNodes.add(nodeId);
        }
        render();
    }

    function toggleExpandPane(nodeId, paneIndex) {
        const pane = State.panes[paneIndex];
        if (pane.expandedNodes.has(nodeId)) {
            pane.expandedNodes.delete(nodeId);
        } else {
            pane.expandedNodes.add(nodeId);
        }
        // Also sync to active state if this is the active pane
        if (paneIndex === State.activePane) {
            State.expandedNodes = pane.expandedNodes;
        }
        render();
    }

    function handleNodeClickPane(nodeId, paneIndex) {
        if (State.editingNodeId) return;

        // If clicking on a different pane, activate it
        if (paneIndex !== State.activePane) {
            setActivePane(paneIndex);
        }

        const pane = State.panes[paneIndex];
        if (pane.selectedId === nodeId) {
            // Double-click behavior: push view
            pushViewPane(nodeId, paneIndex);
        } else {
            // Single click: select
            selectNodePane(nodeId, paneIndex);
        }
    }

    function selectNodePane(nodeId, paneIndex) {
        const pane = State.panes[paneIndex];
        pane.selectedId = nodeId;
        if (paneIndex === State.activePane) {
            State.selectedId = nodeId;
        }
        render();
    }

    function pushViewPane(nodeId, paneIndex) {
        const pane = State.panes[paneIndex];
        if (pane.rootId) {
            pane.history.push(pane.rootId);
            pane.forwardHistory = [];
        }
        getViewForPane(nodeId, paneIndex);
    }

    function getViewForPane(rootId, paneIndex, height = null) {
        const pane = State.panes[paneIndex];
        const viewHeight = height || pane.viewDepth || 2;
        sendAction({
            action: 'net.fortytwo.smsn.server.actions.GetView',
            root: rootId,
            height: viewHeight,
            filter: State.filter,
            style: pane.viewStyle
        }, (data) => {
            if (data.view) {
                pane.view = data.view;
                pane.rootId = data.root || data.view.id;
                if (paneIndex === State.activePane) {
                    State.view = pane.view;
                    State.rootId = pane.rootId;
                }
                render();
                setStatusMessage('View loaded');
            }
        });
        updateToolbar();
    }

    function popViewPane(paneIndex) {
        const pane = State.panes[paneIndex];
        if (pane.history.length > 0) {
            if (pane.rootId) {
                pane.forwardHistory.push(pane.rootId);
            }
            const prevId = pane.history.pop();
            navigateToId(prevId, paneIndex);
        }
        updateToolbar();
    }

    function forwardViewPane(paneIndex) {
        const pane = State.panes[paneIndex];
        if (pane.forwardHistory.length > 0) {
            if (pane.rootId) {
                pane.history.push(pane.rootId);
            }
            const nextId = pane.forwardHistory.pop();
            navigateToId(nextId, paneIndex);
        }
        updateToolbar();
    }

    function setViewStylePane(style, paneIndex) {
        const pane = State.panes[paneIndex];
        pane.viewStyle = style;
        updateToolbar();
        if (pane.rootId) {
            getViewForPane(pane.rootId, paneIndex);
        }
    }

    function refreshViewPane(paneIndex) {
        const pane = State.panes[paneIndex];
        if (pane.rootId) {
            getViewForPane(pane.rootId, paneIndex);
        }
    }

    function setViewDepth(paneIndex, depth) {
        const pane = State.panes[paneIndex];
        pane.viewDepth = parseInt(depth, 10);
        if (pane.rootId) {
            getViewForPane(pane.rootId, paneIndex, pane.viewDepth);
        }
    }

    function gotoAlias() {
        if (!State.selectedId) {
            setStatusMessage('No note selected');
            return;
        }

        const pane = getPane();
        const node = findNodeById(pane.view, State.selectedId);
        if (!node) {
            setStatusMessage('Note not found');
            return;
        }

        // Check if node has a shortcut or alias - navigate to it
        const shortcutOrAlias = node.shortcut || node.alias;
        if (shortcutOrAlias) {
            searchShortcut(shortcutOrAlias);
            return;
        }

        // Check if title looks like a URL - open in new tab
        const title = node.title || '';
        const urlPattern = /^(https?:\/\/|www\.)/i;
        if (urlPattern.test(title)) {
            const url = title.startsWith('www.') ? 'https://' + title : title;
            window.open(url, '_blank');
            setStatusMessage('Opened URL in new tab');
            return;
        }

        // Check if title contains a URL
        const urlMatch = title.match(/(https?:\/\/[^\s]+)/i);
        if (urlMatch) {
            window.open(urlMatch[1], '_blank');
            setStatusMessage('Opened URL in new tab');
            return;
        }

        setStatusMessage('No alias or URL to visit');
    }

    function searchShortcut(shortcut) {
        sendAction({
            action: 'net.fortytwo.smsn.server.actions.Search',
            query: shortcut,
            queryType: 'Shortcut',
            height: 2,
            filter: State.filter
        }, (data) => {
            if (data.view && data.view.children && data.view.children.length > 0) {
                // Navigate to the first result
                const targetId = data.view.children[0].id;
                pushView(targetId);
                setStatusMessage('Jumped to: ' + shortcut);
            } else {
                setStatusMessage('Shortcut not found: ' + shortcut);
            }
        });
    }

    // =============================================================================
    // Editing Functions
    // =============================================================================

    function startEditTitle(nodeId) {
        State.editingNodeId = nodeId;
        render();

        setTimeout(() => {
            const input = document.getElementById('edit-title-input');
            if (input) {
                input.focus();
                input.select();
            }
        }, 0);
    }

    function cancelEditTitle() {
        State.editingNodeId = null;
        render();
    }

    function saveEditTitle() {
        const input = document.getElementById('edit-title-input');
        if (!input || !State.editingNodeId) return;

        const newTitle = input.value.trim();
        if (!newTitle) {
            setStatusMessage('Title cannot be empty');
            return;
        }

        const nodeId = State.editingNodeId;
        State.editingNodeId = null;

        setProperty(nodeId, 'title', newTitle, () => {
            const node = findNodeById(State.view, nodeId);
            if (node) {
                node.title = newTitle;
            }
            render();
            setStatusMessage('Title updated');
        });
    }

    function showProperties() {
        if (!State.selectedId) return;

        const node = findNodeById(State.view, State.selectedId);
        if (!node) return;

        document.getElementById('prop-title').value = node.title || '';
        document.getElementById('prop-weight').value = node.weight || 0.5;
        document.getElementById('prop-weight-value').textContent = (node.weight || 0.5).toFixed(1);
        document.getElementById('prop-priority').value = node.priority || 0;
        document.getElementById('prop-priority-value').textContent = node.priority ? node.priority.toFixed(1) : '-';
        document.getElementById('prop-source').value = node.source || 'private';
        document.getElementById('prop-shortcut').value = node.shortcut || '';

        document.getElementById('properties-overlay').classList.add('visible');
        document.getElementById('prop-title').focus();
    }

    function hideProperties() {
        document.getElementById('properties-overlay').classList.remove('visible');
    }

    function saveProperties() {
        if (!State.selectedId) return;

        const nodeId = State.selectedId;
        const props = {
            title: document.getElementById('prop-title').value.trim(),
            weight: parseFloat(document.getElementById('prop-weight').value),
            priority: parseFloat(document.getElementById('prop-priority').value),
            source: document.getElementById('prop-source').value,
            shortcut: document.getElementById('prop-shortcut').value.trim()
        };

        hideProperties();

        let updates = [];

        const node = findNodeById(State.view, nodeId);
        if (props.title && props.title !== node.title) {
            updates.push(['title', props.title]);
        }
        if (props.weight !== node.weight) {
            updates.push(['weight', props.weight]);
        }
        if (props.priority !== (node.priority || 0)) {
            updates.push(['priority', props.priority]);
        }
        if (props.source !== node.source) {
            updates.push(['source', props.source]);
        }
        if (props.shortcut !== (node.shortcut || '')) {
            updates.push(['shortcut', props.shortcut || null]);
        }

        if (updates.length === 0) {
            setStatusMessage('No changes');
            return;
        }

        function sendNext(index) {
            if (index >= updates.length) {
                getView(State.rootId);
                setStatusMessage('Properties updated');
                return;
            }

            const [name, value] = updates[index];
            setProperty(nodeId, name, value, () => {
                sendNext(index + 1);
            });
        }

        sendNext(0);
    }

    function showNewNote(mode) {
        State.newNoteMode = mode;
        document.getElementById('new-note-title').textContent =
            mode === 'child' ? 'New Child Note' : 'New Sibling Note';
        document.getElementById('new-note-input').value = '';
        document.getElementById('new-note-overlay').classList.add('visible');
        document.getElementById('new-note-input').focus();
    }

    function hideNewNote() {
        document.getElementById('new-note-overlay').classList.remove('visible');
        State.newNoteMode = null;
    }

    function createNewNote() {
        const title = document.getElementById('new-note-input').value.trim();
        if (!title) {
            setStatusMessage('Title cannot be empty');
            return;
        }

        hideNewNote();

        if (State.newNoteMode === 'child') {
            const parentId = State.selectedId || State.rootId;
            if (!parentId) {
                setStatusMessage('No parent selected');
                return;
            }

            const parent = findNodeById(State.view, parentId);
            let wikiContent = '';

            if (parent && parent.children) {
                for (const child of parent.children) {
                    wikiContent += `* ${child.title}\n    :${child.id}:\n`;
                }
            }
            wikiContent += `* ${title}\n`;

            updateView(parentId, wikiContent, 2);

        } else if (State.newNoteMode === 'sibling') {
            if (!State.selectedId || State.selectedId === State.rootId) {
                setStatusMessage('Cannot add sibling to root');
                return;
            }

            const parentId = findParentId(State.view, State.selectedId);
            if (!parentId) {
                setStatusMessage('Could not find parent');
                return;
            }

            const parent = findNodeById(State.view, parentId);
            let wikiContent = '';

            if (parent && parent.children) {
                for (const child of parent.children) {
                    wikiContent += `* ${child.title}\n    :${child.id}:\n`;
                    if (child.id === State.selectedId) {
                        wikiContent += `* ${title}\n`;
                    }
                }
            }

            updateView(parentId, wikiContent, 2);
        }
    }

    function showConfirmDelete() {
        if (!State.selectedId) return;

        const node = findNodeById(State.view, State.selectedId);
        if (!node) return;

        const childCount = node.numberOfChildren || (node.children ? node.children.length : 0);
        let message = `Delete "${node.title}"?`;
        if (childCount > 0) {
            message += `<br><br><span style="color: var(--warning-color)">This note has ${childCount} children. They will become orphaned.</span>`;
        }

        document.getElementById('confirm-message').innerHTML = message;
        document.getElementById('confirm-overlay').classList.add('visible');
    }

    function hideConfirm() {
        document.getElementById('confirm-overlay').classList.remove('visible');
    }

    function confirmDelete() {
        hideConfirm();

        if (!State.selectedId || State.selectedId === State.rootId) {
            setStatusMessage('Cannot delete root');
            return;
        }

        const parentId = findParentId(State.view, State.selectedId);
        if (!parentId) {
            setStatusMessage('Could not find parent');
            return;
        }

        const parent = findNodeById(State.view, parentId);
        let wikiContent = '';

        if (parent && parent.children) {
            for (const child of parent.children) {
                if (child.id !== State.selectedId) {
                    wikiContent += `* ${child.title}\n    :${child.id}:\n`;
                }
            }
        }

        State.selectedId = null;
        updateView(parentId, wikiContent, 2);
        setStatusMessage('Note removed from parent');
    }

    // =============================================================================
    // Tree Utilities
    // =============================================================================

    function findNodeById(node, id) {
        if (!node) return null;
        if (node.id === id) return node;
        if (node.children) {
            for (const child of node.children) {
                const found = findNodeById(child, id);
                if (found) return found;
            }
        }
        return null;
    }

    function findParentId(node, childId, parentId = null) {
        if (!node) return null;
        if (node.id === childId) return parentId;
        if (node.children) {
            for (const child of node.children) {
                const found = findParentId(child, childId, node.id);
                if (found) return found;
            }
        }
        return null;
    }

    function getVisibleNodeIds() {
        const ids = [];
        collectVisibleIds(State.view, true, ids);
        return ids;
    }

    function collectVisibleIds(node, isRoot, ids) {
        if (!node) return;
        ids.push(node.id);
        const isExpanded = State.expandedNodes.has(node.id) || isRoot;
        if (isExpanded && node.children) {
            for (const child of node.children) {
                collectVisibleIds(child, false, ids);
            }
        }
    }

    function moveSelection(direction) {
        const visibleIds = getVisibleNodeIds();
        if (visibleIds.length === 0) return;

        const currentIndex = visibleIds.indexOf(State.selectedId);
        let newIndex;

        if (currentIndex === -1) {
            newIndex = direction > 0 ? 0 : visibleIds.length - 1;
        } else {
            newIndex = currentIndex + direction;
            if (newIndex < 0) newIndex = 0;
            if (newIndex >= visibleIds.length) newIndex = visibleIds.length - 1;
        }

        selectNode(visibleIds[newIndex]);

        const selectedEl = document.querySelector(`.tree-node[data-id="${State.selectedId}"]`);
        if (selectedEl) {
            selectedEl.scrollIntoView({ block: 'nearest' });
        }
    }

    // =============================================================================
    // Rendering
    // =============================================================================

    function render() {
        renderPane(0);
        if (State.splitView) {
            renderPane(1);
        }
        updateNodeCount();
    }

    function renderPane(paneIndex) {
        const containerId = `tree-container-${paneIndex}`;
        const container = document.getElementById(containerId);
        const pane = State.panes[paneIndex];

        if (!pane.view) {
            container.innerHTML = '<div class="loading">No data</div>';
            return;
        }

        // Render using pane-specific state
        container.innerHTML = renderNodeForPane(pane.view, true, 0, paneIndex);
    }

    function renderNodeForPane(node, isRoot, depth, paneIndex) {
        if (!node) return '';

        const pane = State.panes[paneIndex];
        const hasChildren = node.children && node.children.length > 0;
        const isExpanded = pane.expandedNodes.has(node.id) || isRoot;
        const isSelected = pane.selectedId === node.id;
        const isEditing = State.editingNodeId === node.id;

        const toggleIcon = hasChildren ? (isExpanded ? '▼' : '▶') : '·';

        const weight = parseFloat(node.weight) || 0.5;
        const source = node.source || 'private';
        const shortcutOrAlias = node.shortcut || node.alias;  // Check both fields
        const hasAlias = !!shortcutOrAlias;
        const hasPriority = node.priority && node.priority > 0;

        const textColor = getNoteColor(source, weight);

        const priorityHtml = hasPriority
            ? `<span class="node-priority" title="Priority: ${node.priority.toFixed(1)}">!</span>`
            : `<span class="priority-spacer"></span>`;

        const childCountHtml = hasChildren && !isExpanded
            ? `<span class="node-meta">(${node.numberOfChildren || node.children.length})</span>`
            : '';

        let titleHtml;
        if (isEditing) {
            titleHtml = `<input type="text" class="edit-input" id="edit-title-input"
                value="${escapeAttr(node.title || '')}"
                onkeydown="handleEditKeydown(event)"
                onblur="cancelEditTitle()" />`;
        } else {
            const titleText = escapeHtml(node.title || '[no title]');
            const aliasClass = hasAlias ? ' has-alias' : '';
            titleHtml = `<span style="color: ${textColor}" class="${aliasClass}" title="${hasAlias ? 'Alias: ' + shortcutOrAlias : ''}">${titleText}</span>`;
        }

        let html = `
            <div class="tree-node ${isRoot ? 'root' : ''} ${isSelected ? 'selected' : ''} ${isEditing ? 'editing' : ''}"
                 data-id="${node.id}" data-depth="${depth}" data-pane="${paneIndex}">
                ${priorityHtml}
                <span class="toggle" style="color: ${textColor}" onclick="event.stopPropagation(); toggleExpandPane('${node.id}', ${paneIndex})">${toggleIcon}</span>
                <div class="node-content" onclick="handleNodeClickPane('${node.id}', ${paneIndex})">
                    <span class="node-title">${titleHtml}</span>
                    ${childCountHtml}
                </div>
            </div>
        `;

        if (hasChildren) {
            html += `<div class="children ${isExpanded ? '' : 'collapsed'}">`;
            for (const child of node.children) {
                html += renderNodeForPane(child, false, depth + 1, paneIndex);
            }
            html += '</div>';
        }

        return html;
    }

    function renderNode(node, isRoot = false, depth = 0) {
        if (!node) return '';

        const hasChildren = node.children && node.children.length > 0;
        const isExpanded = State.expandedNodes.has(node.id) || isRoot;
        const isSelected = State.selectedId === node.id;
        const isEditing = State.editingNodeId === node.id;

        const toggleIcon = hasChildren ? (isExpanded ? '▼' : '▶') : '·';

        const weight = parseFloat(node.weight) || 0.5;
        const source = node.source || 'private';
        const shortcutOrAlias = node.shortcut || node.alias;  // Check both fields
        const hasAlias = !!shortcutOrAlias;
        const hasPriority = node.priority && node.priority > 0;

        const textColor = getNoteColor(source, weight);

        const priorityHtml = hasPriority
            ? `<span class="node-priority" title="Priority: ${node.priority.toFixed(1)}">!</span>`
            : '';

        const childCountHtml = hasChildren && !isExpanded
            ? `<span class="node-meta">(${node.numberOfChildren || node.children.length})</span>`
            : '';

        let titleHtml;
        if (isEditing) {
            titleHtml = `<input type="text" class="edit-input" id="edit-title-input"
                value="${escapeAttr(node.title || '')}"
                onkeydown="handleEditKeydown(event)"
                onblur="cancelEditTitle()" />`;
        } else {
            const titleText = escapeHtml(node.title || '[no title]');
            const aliasClass = hasAlias ? ' has-alias' : '';
            titleHtml = `<span style="color: ${textColor}" class="${aliasClass}">${titleText}</span>`;
        }

        let html = `
            <div class="tree-node ${isRoot ? 'root' : ''} ${isSelected ? 'selected' : ''} ${isEditing ? 'editing' : ''}"
                 data-id="${node.id}" data-depth="${depth}">
                <span class="toggle" style="color: ${textColor}" onclick="event.stopPropagation(); toggleExpand('${node.id}')">${toggleIcon}</span>
                <div class="node-content" onclick="handleNodeClick('${node.id}')">
                    <span class="node-title">${priorityHtml}${titleHtml}</span>
                    ${childCountHtml}
                </div>
            </div>
        `;

        if (hasChildren) {
            html += `<div class="children ${isExpanded ? '' : 'collapsed'}">`;
            for (const child of node.children) {
                html += renderNode(child, false, depth + 1);
            }
            html += '</div>';
        }

        return html;
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function escapeAttr(text) {
        return text.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
    }

    // =============================================================================
    // UI Updates
    // =============================================================================

    function updateConnectionStatus(status) {
        const el = document.getElementById('connection-status');
        el.className = status;

        switch (status) {
            case 'connected':
                el.textContent = 'Connected';
                break;
            case 'connecting':
                el.textContent = 'Connecting...';
                break;
            case 'disconnected':
                el.textContent = 'Disconnected (reconnecting...)';
                break;
            case 'error':
                el.textContent = 'Connection error';
                break;
        }
    }

    function setStatusMessage(msg) {
        document.getElementById('status-message').textContent = msg;
    }

    function updateNodeCount() {
        const count = countNodes(State.view);
        document.getElementById('node-count').textContent = `${count} notes`;
    }

    function countNodes(node) {
        if (!node) return 0;
        let count = 1;
        if (node.children) {
            for (const child of node.children) {
                count += countNodes(child);
            }
        }
        return count;
    }

    function updateSourceOptions() {
        const select = document.getElementById('prop-source');
        select.innerHTML = '';

        if (State.config && State.config.sources) {
            State.config.sources.forEach(s => {
                const option = document.createElement('option');
                option.value = s.name;
                option.textContent = s.name;
                select.appendChild(option);
            });
        }
    }

    function updateSourceLegend() {
        const legend = document.getElementById('source-legend');
        legend.innerHTML = '';

        if (State.config && State.config.sources) {
            // Show all sources in the legend
            State.config.sources.forEach(s => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="legend-color" style="background: ${colorToHex(parseColor(s.color))}"></div>
                    <span>${s.name}</span>
                `;
                legend.appendChild(item);
            });
        }
    }

    function toggleHelp() {
        document.getElementById('help-overlay').classList.toggle('visible');
    }

    function hideHelp() {
        document.getElementById('help-overlay').classList.remove('visible');
    }

    // =============================================================================
    // Event Handlers
    // =============================================================================

    function handleNodeClick(nodeId) {
        if (State.editingNodeId) return;

        if (State.selectedId === nodeId) {
            pushView(nodeId);
        } else {
            selectNode(nodeId);
        }
    }

    function handleEditKeydown(event) {
        if (event.key === 'Enter') {
            event.preventDefault();
            saveEditTitle();
        } else if (event.key === 'Escape') {
            event.preventDefault();
            cancelEditTitle();
        }
    }

    // Property sliders
    document.getElementById('prop-weight').addEventListener('input', (e) => {
        document.getElementById('prop-weight-value').textContent = parseFloat(e.target.value).toFixed(1);
    });

    document.getElementById('prop-priority').addEventListener('input', (e) => {
        const val = parseFloat(e.target.value);
        document.getElementById('prop-priority-value').textContent = val > 0 ? val.toFixed(1) : '-';
    });

    // New note input
    document.getElementById('new-note-input').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            createNewNote();
        } else if (e.key === 'Escape') {
            hideNewNote();
        }
    });

    // =============================================================================
    // Keyboard Handling
    // =============================================================================

    document.addEventListener('keydown', (e) => {
        const activeSearchInput = document.getElementById(`search-input-${State.activePane}`);
        const inSearch = document.activeElement && document.activeElement.classList.contains('search-input');
        const helpVisible = document.getElementById('help-overlay').classList.contains('visible');
        const propsVisible = document.getElementById('properties-overlay').classList.contains('visible');
        const confirmVisible = document.getElementById('confirm-overlay').classList.contains('visible');
        const newNoteVisible = document.getElementById('new-note-overlay').classList.contains('visible');
        const inOverlay = propsVisible || confirmVisible || newNoteVisible;

        if (e.key === 'Escape') {
            if (State.editingNodeId) {
                cancelEditTitle();
            } else if (helpVisible) {
                hideHelp();
            } else if (propsVisible) {
                hideProperties();
            } else if (confirmVisible) {
                hideConfirm();
            } else if (newNoteVisible) {
                hideNewNote();
            } else if (inSearch) {
                document.activeElement.value = '';
                document.activeElement.blur();
            }
            return;
        }

        if (State.editingNodeId) return;
        if (inOverlay) return;

        if (helpVisible) {
            hideHelp();
            return;
        }

        if (inSearch) {
            if (e.key === 'Enter') {
                const query = document.activeElement.value.trim();
                // Determine which pane this search input belongs to
                const inputId = document.activeElement.id;
                const paneIndex = inputId.endsWith('-0') ? 0 : 1;
                if (query) {
                    searchInPane(query, paneIndex);
                }
            }
            return;
        }

        switch (e.key) {
            case 'Tab':
                if (State.splitView) {
                    e.preventDefault();
                    setActivePane(State.activePane === 0 ? 1 : 0);
                }
                break;
            case '/':
                e.preventDefault();
                if (activeSearchInput) activeSearchInput.focus();
                break;
            case '?':
                toggleHelp();
                break;
            case 'j':
                moveSelection(1);
                break;
            case 'k':
                moveSelection(-1);
                break;
            case 'h':
                if (State.selectedId && State.expandedNodes.has(State.selectedId)) {
                    toggleExpand(State.selectedId);
                }
                break;
            case 'l':
                if (State.selectedId) {
                    const node = findNodeById(State.view, State.selectedId);
                    if (node && node.children && node.children.length > 0 && !State.expandedNodes.has(State.selectedId)) {
                        toggleExpand(State.selectedId);
                    }
                }
                break;
            case 'Enter':
                if (State.selectedId) {
                    pushView(State.selectedId);
                }
                break;
            case 'Backspace':
                e.preventDefault();
                popView();
                break;
            case 'r':
                if (State.rootId) {
                    getView(State.rootId);
                } else {
                    findRoots();
                }
                break;
            case 'e':
                if (State.selectedId) {
                    startEditTitle(State.selectedId);
                }
                break;
            case 'n':
                showNewNote('child');
                break;
            case 'N':
                showNewNote('sibling');
                break;
            case 'p':
                showProperties();
                break;
            case 'd':
                showConfirmDelete();
                break;
            case 'g':
                gotoAlias();
                break;
        }
    });

    // =============================================================================
    // Initialization
    // =============================================================================

    connect();

    </script>
</body>
</html>
